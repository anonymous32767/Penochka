<!doctype html>
<html>
<head>
  <title>kernel &#8212; Ядерные функции</title>
  <link href="style.css" type="text/css" rel="stylesheet" />
</head>
<body>
<h1>kernel &#8212; Ядерные функции</h1>
<p class="abstract">Наиболее общеупотребительные функции пеночки</p>
<p>В своей работе пеночка опирается прежде всего на библиотеку jQuery,         которая и может считаться ядром, однако одной её недостаточно. Все что она дает нам &#8212; это т.н. fun dom, &#8212; то есть упрощение операций над DOM. Для обеспечения модульности же необходима сигнальная система.</p><p>        Помимо этого есть пара-тройка вспомагательных сущностей, которые         нужны пеночке и отсутствуют в jQuery. Они так же содержатся в данном модуле.</p>

<p> <h3>Таймер</h3> 
        Простейший таймер для замера производительности пеночки и некоего         простейшего профайлинга. Имеет две функции: <tt>init()</tt> &#8212; для         установки начала замера и <tt>check(str)</tt> &#8212; для фиксации момента         времени (str &#8212; строка, описывающая фиксируемый момент времени).</p><p>        Функция <tt>init()</tt> вызывается сразу же по созданию таймера. Хотя даже         в этом случае её результаты будут не совсем точны, ибо не будет учитываться лаг, связанный с загрузкой всех модулей до этого. То есть, фактически, не будет учитываться время загрузки библиотеки jQuery.</p>

<p><pre>(jQuery.timer = {
      total : 0,
      init : function() {
         this.time = (new Date()).getTime();
      }, check : function(str) {
         var delta = (new Date()).getTime() - this.time
         this.total += delta;
         this.cache += str + ': ' + delta + 'мсек; ';
         this.time = (new Date()).getTime()
      },
      cache : '',
      time : null
   }).init()
      </pre></p>

<p>Начальной реализацией таймера мы обязаны эврикафагу.</p>

<p> <h3>Вторая сигнальная система</h3> 
        Тестирование производительности браузерного яваскрипта [<a href=#jsspeed>jsspeed</a>]         показало, что встроенные браузерные события или (а) довольно ресурсоемкая штука, или (б) достаточно сложны в освоении. Поэтому в пеночке реализована своя, вторая сигнальная система. Приемущества велосипеда тут еще и в том, что если что-то не устраивает, к примеру порядок выполнения событий или отсутсвие их приоритезации, можно реализовать это как следует. Браузер же, а тем более несколько их, так просто не перекомпилируешь.</p><p>        Вторая сигнальная система состоит из хранилища событий, переменной         <tt>events</tt> </p>

<p><pre>var events = {}</pre></p>

<p>, события в которой хранятся как именованые массивы обработчиков, и двух функций: <tt>to(evname, cookie)</tt> и <tt>on(evname, fun)</tt> , служащих для подписки на событие и отправки какого-либо события соотвественно.</p><p>        Функция подписки на события <tt>on(evname, fun)</tt> позволяет добавить обработчик к одному или нескольким событиям. В случае одного обработчика передается его имя, в случае нескольких &#8212;  массив имен.</p>

<p><pre>jQuery.on = function(evname, fun) {
      evname = $.makeArray(evname)
      for (var i = 0; i < evname.length; i++) {
         try {
            events[evname[i]].push(fun)
         } catch (err) {
            events[evname[i]] = [fun]
         }
      }
   }</pre></p>

<p>Функция <tt>to(evname, cookie)</tt> последовательно вызывает обработчики         события <tt>evname</tt> . По средством аргумента <tt>cookie</tt> реализована         возможность управления реализации события и обмена данными между         обработчиками. Выглядит это примерно так:</p><p>        <img src="eventpass.gif">Реализация событий</img> </p>

<p><pre>jQuery.to = function (evname, cookie) {
      try {
         for(var i = 0; cookie != null && i < events[evname].length; i++)
            cookie = events[evname][i](cookie)
         return cookie
      } catch (err) { return null }
   }</pre></p>

<p>Добавление собственных стилей в страничку. То есть общего css, а не         к конкретным элементам [<a href=#csssrc>csssrc</a>]. </p>

<p><pre>jQuery.css = function  ( css ) {
      var style = document.createElement( 'style' );
      style.type = 'text/css';
      var head = document.getElementsByTagName('head')[0];
      head.appendChild( style );
      if( style.styleSheet )  /* IE */
         style.styleSheet.cssText = css;
      else  /* other browsers */
         style.appendChild( document.createTextNode(css) );
      return style;
   }</pre></p>

<p>В jQuery есть функция @replaceWith@, то есть заменяющая одно на         другое, но нет функции, меняющей элементы местами. Исправляем         недостаток. Пока релизация страдает: меняются местами только первые         две ноды, а не массивы элементов.</p>

<p><pre>jQuery.extend({
      swap:function(b){
         b = $(b)[0]
         var a = this[0];
         var t = a.parentNode.insertBefore(document.createTextNode(''), a);
         b.parentNode.insertBefore(a, b);
         t.parentNode.insertBefore(b, t);
         t.parentNode.removeChild(t);
         return this;
      }
   })</pre></p>

<p>Определим пространство имен для селекторов, специфических для         конкретной борды.</p>

<p><pre>jQuery.ss = {}</pre></p>
</body></html>
<h2>Bibliography</h2>
<dl>
<dt><sup>[<a name="jsspeed">jsspeed</a>]</sup><dd><a href="http://github.com/anonymous32767/Penochka/raw/doc/doc/jsspeed.pdf">Некоторые специфические замеры скорости яваскрипта</a> </li>
<dt><sup>[<a name="csssrc">csssrc</a>]</sup><dd><a href="http://www.mail-archive.com/jquery-en@googlegroups.com/msg16487.html">Оригинальное                                  происхождение</a>          процедуры <tt>$.css</tt> </li>
</dl>

<!doctype html>
<html>
<head>
  <title>imagesUnfolding &#8212; Раскрытие изображений</title>
  <link href="style.css" type="text/css" rel="stylesheet" />
</head>
<body>
<h1>imagesUnfolding &#8212; Раскрытие изображений</h1>
<p class="abstract">Развертка изображений которые обернуты ссылками, ведущими на оригиналы</p>
<p>Задача развертки изображения разбивается на две подзадачи: (а) 	  определить, что изображение, по которому кликнул пользователь, может быть развернуто и (б) собрать информацию, необходимую для развертывания и развернуть.</p><p>		  Первая задача решается в обработчике события функцией <tt>testThumb(elt)</tt> .</p>

<p><pre>function testThumb (subj) {
      return subj.is('img')
         && ({jpeg:1,jpg:1,png:1,gif:1,tiff:1,bmp:1})
      [subj.closest('a').attr('href').
       replace(/^.*\.(\w+)$/,'$1').toLowerCase()]
   }</pre></p>

<p>Несмотря на страшный вид, в ней нет ничего сложного &#8212; она проверяет, что (а) изображение обернуто ссылкой и (б) ссылка ведет на изображение.</p>

<p>Задача разворота изображения решается следующим обрабом. В элементе    <tt>img</tt> изображения создается атрибут <tt>altimg@, содержащий html-код развернутого изображения. При необходимости развернуть/свернуть изображение оригинальные элемент и содержимое аттрибута меняются местами. Например, пусть у нас имеется некое разворачиваемое изображение @<img thumb></tt> . Мы создаем код развернутой копии этого изображения <tt><img full></tt> и помещаем в  аттрибут <tt>altimg</tt> исходного: <tt><img thumb altimg="<img full>">@. А потом,   как уже говорилось, меняем их местами.</p><p>Алгоритм кажется сложноватым, особенно когда знаешь, что можно было бы просто изменять аттрибут @src</tt> . Однако на практике такой способ хуже, потому что изображение в этом случае обновится только после окончательной   загрузки полной копии. А этого приходится ждать, например когда грузится   анимированный gif. Во время же ожидания ничего не происходит, а подобные ситуации всегда некомфортны для пользователя.</p><p>Вышеописанное реализуется двумя функциями: <tt>prepareFull(subj)</tt> и	  <tt>toggleFull(subj)</tt> . Их работа понятна из исходного кода.</p>

<p><pre>   function prepareFull (subj) {
      return '<img src="' + subj.parent().attr('href') + '" ' +
         'style="min-width:' + subj.attr('width') + 'px;' +
         'min-height:' + subj.attr('height') + 'px;" ' + 
			'class="penImageFull" >'
   }

   function toggleFull (subj) {
      if (!subj.attr('altimg'))
         var t = prepareFull(subj)
      else
         var t = subj.attr('altimg')

      subj.removeAttr('altimg')
      var alt = $(t).attr('altimg', subj.parent().html())
      subj.replaceWith(alt)
   }</pre></p>

<p>Обработчик события. Проверяет, что кликнуто именно левой кнопкой мыши и вызывает вышеописанные функции.</p>

<p><pre>$.on(
      'click',
      function (e) {
         var subj = $(e.target)
         if (e.which == 1 && testThumb(subj)) {
            toggleFull(subj)
            return false
         } else {
            return e
         }
      })</pre></p>
</body></html>

module kernel {Ядерные функции}\
{Наиболее общеупотребительные функции пеночки}\
{
   header ; jquery

   doc {В своей работе пеночка опирается прежде всего на библиотеку jQuery,         которая и может считаться ядром, однако одной её недостаточно. Все что она дает нам --- это т.н. fun dom, --- то есть упрощение операций над DOM. Для обеспечения модульности же необходима сигнальная система.

        Помимо этого есть пара-тройка вспомагательных сущностей, которые         нужны пеночке и отсутствуют в jQuery. Они так же содержатся в данном модуле.}

   doc { **Таймер**

        Простейший таймер для замера производительности пеночки и некоего         простейшего профайлинга. Имеет две функции: @init()@ --- для         установки начала замера и @check(str)@ --- для фиксации момента         времени (str --- строка, описывающая фиксируемый момент времени).

        Функция @init()@ вызывается сразу же по созданию таймера. Хотя даже         в этом случае её результаты будут не совсем точны, ибо не будет учитываться лаг, связанный с загрузкой всех модулей до этого. То есть, фактически, не будет учитываться время загрузки библиотеки jQuery.}

   js {$.timer = {
		time : __startup,
      total : 0,
      init : function() {
         this.time = (new Date()).getTime();
      }, check : function(str) {
         var delta = (new Date()).getTime() - this.time
         this.total += delta;
         this.cache += str + ': ' + delta + 'мсек; ';
         this.time = (new Date()).getTime()
      },
      cache : ''
   }
      }

	doc {Начальной реализацией таймера мы обязаны эврикафагу.}

   doc { **Вторая сигнальная система**

        Тестирование производительности браузерного яваскрипта [jsspeed]         показало, что встроенные браузерные события или (а) довольно ресурсоемкая штука, или (б) достаточно сложны в освоении. Поэтому в пеночке реализована своя, вторая сигнальная система. Приемущества велосипеда тут еще и в том, что если что-то не устраивает, к примеру порядок выполнения событий или отсутсвие их приоритезации, можно реализовать это как следует. Браузер же, а тем более несколько их, так просто не перекомпилируешь.

        Вторая сигнальная система состоит из хранилища событий, переменной         @events@ }

   js {var events = {}}

   doc {, события в которой хранятся как именованые массивы обработчиков, и двух функций: @to(evname, cookie)@ и @on(evname, fun)@ , служащих для подписки на событие и отправки какого-либо события соотвественно.

        Функция подписки на события @on(evname, fun)@ позволяет добавить обработчик к одному или нескольким событиям. В случае одного обработчика передается его имя, в случае нескольких ---  массив имен.}

   js {$.on = function(evname, fun) {
      evname = $.makeArray(evname)
      for (var i = 0; i < evname.length; i++) {
         try {
            events[evname[i]].push(fun)
         } catch (err) {
            events[evname[i]] = [fun]
         }
      }
   }}

   doc {Функция @to(evname, cookie)@ последовательно вызывает обработчики         события @evname@ . По средством аргумента @cookie@ реализована         возможность управления реализации события и обмена данными между         обработчиками. Выглядит это примерно так:

        !Реализация событий!:eventpass.gif }

   js {$.to = function (evname, cookie) {
      try {
         for(var i = 0; cookie != null && i < events[evname].length; i++)
            cookie = events[evname][i](cookie)
         return cookie
      } catch (err) { return null }
   }}

   doc {Добавление собственных стилей в страничку. То есть общего css, а не         к конкретным элементам [csssrc]. }

   js {$.css = function  ( css ) {
      var style = document.createElement( 'style' );
      style.type = 'text/css';
      var head = document.getElementsByTagName('head')[0];
      head.appendChild( style );
      if( style.styleSheet )  /* IE */
         style.styleSheet.cssText = css;
      else  /* other browsers */
         style.appendChild( document.createTextNode(css) );
      return style;
   }}

   doc {В jQuery есть функция @replaceWith@, то есть заменяющая одно на         другое, но нет функции, меняющей элементы местами. Исправляем         недостаток. Пока релизация страдает: меняются местами только первые         две ноды, а не массивы элементов.}

   js {$.extend({
      swap:function(b){
         b = $(b)[0]
         var a = this[0];
         var t = a.parentNode.insertBefore(document.createTextNode(''), a);
         b.parentNode.insertBefore(a, b);
         t.parentNode.insertBefore(b, t);
         t.parentNode.removeChild(t);
         return this;
      }
   })}

   doc {Определим пространство имен для селекторов, специфических для         конкретной борды.}

   js {$.ss = {}}

   bib {jsspeed} {"Некоторые специфические замеры скорости яваскрипта":http://github.com/anonymous32767/Penochka/raw/doc/doc/jsspeed.pdf }

   bib {csssrc} {"Оригинальное                                  происхождение":http://www.mail-archive.com/jquery-en@googlegroups.com/msg16487.html          процедуры @$.css@ }

}